// *** Commonly used functions ***

// Trims whitespace from beginning and end of the specified string.
DEFINE_DIMORPHIC_FUNCTION a7_trim
INT_VAR
  trim_before = 1
  trim_after = 1
STR_VAR
  line = ~~
RET
  line
BEGIN
  ACTION_IF (trim_before || trim_after) BEGIN
    OUTER_PATCH_SAVE line ~%line%~ BEGIN
      PATCH_IF (trim_before) BEGIN REPLACE_TEXTUALLY ~^[ %TAB%]+~ ~~ END
      PATCH_IF (trim_after) BEGIN REPLACE_TEXTUALLY ~[ %TAB%]+$~ ~~ END
    END
  END
END


// Adds a "Select Spell" effect to the specified spell ability
DEFINE_PATCH_FUNCTION apply_opcode_214
INT_VAR
  header   = 0
  prob_min = 0
  prob_max = 0
STR_VAR
  resource = ~~
BEGIN
  PATCH_IF (header > 0 && prob_min >= 0 && prob_max <= 100 && prob_min <= prob_max) BEGIN
    LPF ADD_SPELL_EFFECT
    INT_VAR
      opcode = 214    // Select spell
      target = 1      // Self
      power = 1
      parameter2 = 0  // from 2da
      timing = 1      // instant/permanent
      probability1 = prob_max
      probability2 = prob_min
      header
      insert_point = 0
    STR_VAR
      resource = EVAL ~%resource%~
    END

    PATCH_IF (DEBUG_MODE) BEGIN
      // print diagnostic feedback to the combat log
      LPF ADD_SPELL_EFFECT
      INT_VAR
        opcode = 139    // Display string
        target = 1      // Self
        power = 1
        parameter1 = RESOLVE_STR_REF(~Invoking spell list "%resref%"...~)
        timing = 1      // instant/permanent
        probability1 = prob_max
        probability2 = prob_min
        header
        insert_point = 0
      END
    END
  END
END

// Returns first unoccupied spell slot and resref of specified type and level (as SPELL.IDS code), or -1/"" if not available
DEFINE_ACTION_FUNCTION a7_find_free_spell_slot
INT_VAR
  type  = 2
  level = 1
RET
  slot
  resref
BEGIN
  OUTER_SET slot = "-1"
  OUTER_SPRINT resref ~~

  ACTION_DEFINE_ARRAY prefix BEGIN ~MARW~ ~SPPR~ ~SPWI~ ~SPIN~ ~SPCL~ END

  ACTION_IF (type >= 1 && type <= 4 && level >= 0 && level < 10) BEGIN

    OUTER_SET range = 49
    OUTER_SET range_min = type * 1000 + level * 100 + 1
    OUTER_SET range_max = range_min + range

    // initializing list of spell slots as unoccupied
    OUTER_FOR (idx = 0; idx < range; ++idx) BEGIN
      OUTER_SET $slots(~%idx%~) = range_min + idx
    END
    OUTER_SET slots = range

    // marking occupied spell slots
    COPY_EXISTING ~spell.ids~ ~override~
      READ_2DA_ENTRIES_NOW ~spells_table~ 2
      FOR (row = 0; row < spells_table; ++row) BEGIN
        READ_2DA_ENTRY_FORMER ~spells_table~ row 0 value
        PATCH_IF (IS_AN_INT ~value~ && value >= range_min && value < range_max) BEGIN
          SET idx = value - range_min
          SET $slots(~%idx%~) = "-1"
        END
      END
    BUT_ONLY

    // scanning for first unoccupied slot
    OUTER_FOR (idx = 0; idx < range; ++idx) BEGIN
      ACTION_IF ($slots(~%idx%~) >= 0) BEGIN
        OUTER_SET slot = $slots(~%idx%~)
        OUTER_SET index = slot - (type * 1000 + level * 100)
        OUTER_SPRINT resref $prefix(~%type%~)
        ACTION_IF (index < 10) BEGIN
          OUTER_SPRINT resref ~%resref%%level%0%index%~
        END ELSE BEGIN
          OUTER_SPRINT resref ~%resref%%level%%index%~
        END
        OUTER_SET idx = range
      END
    END
  END
END


// Replaces a specific spell code in SPELL.IDS by a new value
DEFINE_PATCH_FUNCTION a7_update_spell_ids_code
INT_VAR
  code      = 0
  new_code  = 0
BEGIN
  PATCH_IF (code >= 1000 && code < 5000 &&
            new_code >= 1000 && new_code < 5000) BEGIN
    SET ofs = 0
    WHILE (ofs >= 0) BEGIN
      SET ofs = INDEX_BUFFER(~^%code% .*~ ofs)
      PATCH_IF (ofs >= 0) BEGIN
        WRITE_ASCIIE ofs ~%new_code%~ (4)
        SET ofs += 4
      END
    END
  END
END

// Replaces all resref occurrences in the current buffer
DEFINE_PATCH_FUNCTION a7_update_resref
INT_VAR
  terminate = 0   // whether to terminate with a '\0'
STR_VAR
  resref_src = ~~ // search string
  resref_dst = ~~ // replacement string
BEGIN
  PATCH_IF (NOT ~%resref_src%~ STR_EQ ~~) BEGIN
    SET ofs = 0
    SET strlen_src = STRING_LENGTH ~%resref_src%~
    SET strlen_dst = terminate ? 8 : STRING_LENGTH ~%resref_dst%~
    WHILE (ofs >= 0) BEGIN
      SET ofs = INDEX_BUFFER(~%resref_src%~ ofs)
      PATCH_IF (ofs >= 0) BEGIN
        WRITE_ASCIIE ofs ~%resref_dst%~ (strlen_dst)
        SET ofs += 1
      END
    END
  END
END


// Replaces matching parameters of all spell or item effects
DEFINE_PATCH_FUNCTION a7_update_effect_params
INT_VAR
  update_global     = 1   // whether to update global effects
  update_ability    = 1   // whether to update effects in ability structures
  match_parameter1  = 0   // whether to update parameter1 field
  match_parameter2  = 0   // whether to update parameter2 field
  match_special     = 0   // whether to update special field
  match_resource    = 0   // whether to update resource field
  opcode            = 0   // opcode to match
  parameter1        = 0   // parameter1 to match (if match_parameter1 = 1)
  new_parameter1    = 0   // parameter1 replacement if matched
  parameter2        = 0   // parameter2 to match (if match_parameter2 = 1)
  new_parameter2    = 0   // parameter2 replacement if matched
  special           = 0   // special to match (if match_special = 1)
  new_special       = 0   // special replacement if matched
STR_VAR
  resource          = ~~  // resource to match (if match_resource = 1)
  new_resource      = ~~  // resource replacement if matched
BEGIN
  READ_ASCII 0x00 sig (4)
  SET sizeAbil = (~%sig%~ STR_EQ ~ITM ~) ? 0x38 : 0x28
  READ_LONG 0x64 ofsAbil
  SET numAbil = update_ability ? (SHORT_AT 0x68) : 0
  READ_LONG 0x6a ofsEffects
  SET idx = update_global ? "-1" : 0
  FOR (idx = idx; idx < numAbil; ++idx) BEGIN
    // negative index indicates global effects
    PATCH_IF (idx < 0) BEGIN
      READ_SHORT 0x6e firstEffect
      READ_SHORT 0x70 numEffects
    END ELSE BEGIN
      SET curOfsAbil = ofsAbil + (idx * sizeAbil)
      READ_SHORT (curOfsAbil + 0x1e) numEffects
      READ_SHORT (curOfsAbil + 0x20) firstEffect
    END
    FOR (idx2 = 0; idx2 < numEffects; ++idx2) BEGIN
      SET curOfsEffect = ofsEffects + (idx2 + firstEffect) * 0x30
      READ_SHORT (curOfsEffect + 0) curOpcode
      PATCH_IF (curOpcode = opcode) BEGIN
        // matching parameter1
        PATCH_IF (match_parameter1) BEGIN
          READ_LONG (curOfsEffect + 0x04) curParameter1
          PATCH_IF (curParameter1 = parameter1) BEGIN
            WRITE_LONG (curOfsEffect + 0x04) new_parameter1
          END
        END
        // matching parameter2
        PATCH_IF (match_parameter2) BEGIN
          READ_LONG (curOfsEffect + 0x08) curParameter2
          PATCH_IF (curParameter2 = parameter2) BEGIN
            WRITE_LONG (curOfsEffect + 0x08) new_parameter2
          END
        END
        // matching special
        PATCH_IF (match_special) BEGIN
          READ_LONG (curOfsEffect + 0x2c) curSpecial
          PATCH_IF (curSpecial = special) BEGIN
            WRITE_LONG (curOfsEffect + 0x2c) new_special
          END
        END
        // matching resource
        PATCH_IF (match_resource) BEGIN
          READ_ASCII (curOfsEffect + 0x14) curResource (8) NULL
          PATCH_IF (~%curResource%~ STR_EQ ~%resource%~) BEGIN
            WRITE_ASCIIE (curOfsEffect + 0x14) ~%new_resource%~ (8)
          END
        END
      END
    END
  END
END


// Removes the line where specified column matches "match"
DEFINE_PATCH_FUNCTION a7_remove_2da_row
INT_VAR column = 0
STR_VAR match  = ~~
BEGIN
  PATCH_IF (NOT ~%match%~ STR_EQ ~~ && column >= 0) BEGIN
    COUNT_2DA_COLS numCols
    PATCH_IF (column < numCols) BEGIN
      COUNT_2DA_ROWS numCols numRows
      SET startRow = 0
      PATCH_IF (numCols < 2) BEGIN SET startRow += 1 END
      PATCH_IF (numCols < 1) BEGIN SET startRow += 1 END
      FOR (row = startRow; row < numRows; ++row) BEGIN
        READ_2DA_ENTRY row column numCols value
        PATCH_IF (~%value%~ STR_EQ ~%match%~) BEGIN
          REMOVE_2DA_ROW row numCols
          SET row = numRows
        END
      END
    END
  END
END


// Automates adding spell effects to items or spells, based on a code sequence
// Code format per effect: "name1=value1,name2=value2;...second effect..."
// Supported parameters:   op (Opcode), tgt (Target), tmg (Timing), pwr (Power), p1 (Parameter1), p2 (Parameter2),
//                         rd (Resist/Dispel), dur (Duration), pro1 (Probability1), pro2 (Probability2), res (Resource),
//                         dnum (Dice Number), dsize (Dice Size), stype (Save Type), sbonus (Save Bonus), spec (Special),
//                         ip (Insert Point), hdr (Header), type (Type)
//                         All parameters except opcode are optional.
// Example:                "op=139,tgt=2,tmg=1,p1=8203;op=215,tgt=2,tmg=1,dur=2,p2=1,res=ICARMOR" adds two effects (139 and 215 with their respective parameters)
DEFINE_PATCH_FUNCTION a7_auto_apply_spl_effect
INT_VAR
  // default values if not specified in "effect_codes"
  def_target        = 0
  def_timing        = 0
  def_power         = 0
  def_parameter1    = 0
  def_parameter2    = 0
  def_resist_dispel = 0
  def_duration      = 0
  def_probability1  = 100
  def_probability2  = 0
  def_dicenumber    = 0
  def_dicesize      = 0
  def_savetype      = 0
  def_savebonus     = 0
  def_special       = 0
  def_insertpoint   = "-1"
  def_header        = 0
  def_type          = 3   // ADD_ITEM_EFFECT only
STR_VAR
  // Supported functions: ADD_SPELL_EFFECT, ADD_SPELL_CFEFFECT, ADD_ITEM_EFFECT, ADD_ITEM_EQEFFECT and (limited) ADD_CRE_EFFECT
  function_name     = ~~
  // The code string with effect definitions
  effect_codes      = ~~
  def_resource      = ~~
BEGIN
  PATCH_IF (NOT ~%function_name%~ STR_EQ ~~) BEGIN
    // parsing effect entries
    SET entries = 0
    SET strlen = STRING_LENGTH ~%effect_codes%~
    INNER_PATCH ~%effect_codes%~ BEGIN
      SET curOfs = 0
      WHILE (curOfs < strlen) BEGIN
        SET ofs = INDEX_BUFFER(~;~ curOfs)
        PATCH_IF (ofs < 0) BEGIN SET ofs = strlen END
        READ_ASCII curOfs entry (ofs - curOfs)
        SPRINT $entries(~%entries%~) ~%entry%~
        SET entries += 1
        SET curOfs = ofs + 1
      END
    END

    // parsing effect parameters
    SET effects = 0
    FOR (idx = 0; idx < entries; ++idx) BEGIN
      SPRINT entry $entries(~%idx%~)
      SET strlen = STRING_LENGTH ~%entry%~
      INNER_PATCH ~%entry%~ BEGIN
        SET curOfs = 0
        WHILE (curOfs < strlen) BEGIN
          SET ofs = INDEX_BUFFER(~,~ curOfs)
          PATCH_IF (ofs < 0) BEGIN SET ofs = strlen END
          READ_ASCII curOfs param (ofs - curOfs)
          INNER_PATCH ~%param%~ BEGIN
            SET ofs2 = INDEX_BUFFER(~=~)
            PATCH_IF (ofs2 > 0) BEGIN
              READ_ASCII 0 v1 (ofs2)
              READ_ASCII (ofs2+1) v2 (BUFFER_LENGTH - ofs2 - 1)
              SPRINT $effects(~%idx%~ ~%v1%~) ~%v2%~ //EVAL ~effects_%idx%_%v1%~ ~%v2%~
            END
          END
          SET curOfs = ofs + 1
        END
      END
    END
    SET effects = entries

    // adding effects
    FOR (idx = 0; idx < effects; ++idx) BEGIN
      SET opcode        = VARIABLE_IS_SET $effects(~%idx%~ ~op~) ? $effects(~%idx%~ ~op~) : ~-1~
      SET target        = VARIABLE_IS_SET $effects(~%idx%~ ~tgt~) ? $effects(~%idx%~ ~tgt~) : def_target
      SET timing        = VARIABLE_IS_SET $effects(~%idx%~ ~tmg~) ? $effects(~%idx%~ ~tmg~) : def_timing
      SET power         = VARIABLE_IS_SET $effects(~%idx%~ ~pwr~) ? $effects(~%idx%~ ~pwr~) : def_power
      SET parameter1    = VARIABLE_IS_SET $effects(~%idx%~ ~p1~) ? $effects(~%idx%~ ~p1~) : def_parameter1
      SET parameter2    = VARIABLE_IS_SET $effects(~%idx%~ ~p2~) ? $effects(~%idx%~ ~p2~) : def_parameter2
      SET resist_dispel = VARIABLE_IS_SET $effects(~%idx%~ ~rd~) ? $effects(~%idx%~ ~rd~) : def_resist_dispel
      SET duration      = VARIABLE_IS_SET $effects(~%idx%~ ~dur~) ? $effects(~%idx%~ ~dur~) : def_duration
      SET probability1  = VARIABLE_IS_SET $effects(~%idx%~ ~pro1~) ? $effects(~%idx%~ ~pro1~) : def_probability1
      SET probability2  = VARIABLE_IS_SET $effects(~%idx%~ ~pro2~) ? $effects(~%idx%~ ~pro2~) : def_probability2
      SET dicenumber    = VARIABLE_IS_SET $effects(~%idx%~ ~dnum~) ? $effects(~%idx%~ ~dnum~) : def_dicenumber
      SET dicesize      = VARIABLE_IS_SET $effects(~%idx%~ ~dsize~) ? $effects(~%idx%~ ~dsize~) : def_dicesize
      SET savingthrow   = VARIABLE_IS_SET $effects(~%idx%~ ~stype~) ? $effects(~%idx%~ ~stype~) : def_savetype
      SET savebonus     = VARIABLE_IS_SET $effects(~%idx%~ ~sbonus~) ? $effects(~%idx%~ ~sbonus~) : def_savebonus
      SET special       = VARIABLE_IS_SET $effects(~%idx%~ ~spec~) ? $effects(~%idx%~ ~spec~) : def_special
      SET insert_point  = VARIABLE_IS_SET $effects(~%idx%~ ~ip~) ? $effects(~%idx%~ ~ip~) : def_insertpoint
      SET header        = VARIABLE_IS_SET $effects(~%idx%~ ~hdr~) ? $effects(~%idx%~ ~hdr~) : def_header
      PATCH_IF (VARIABLE_IS_SET $effects(~%idx%~ ~res~)) BEGIN
        SPRINT resource $effects(~%idx%~ ~res~)
      END ELSE BEGIN
        SPRINT resource ~%def_resource%~
      END
      PATCH_IF (opcode >= 0) BEGIN
        LPF ~%function_name%~
        INT_VAR
          opcode
          target
          timing
          parameter1
          parameter2
          power
          resist_dispel
          duration
          probability1
          probability2
          dicenumber
          dicesize
          savingthrow
          savebonus
          special
          insert_point
          header
        STR_VAR
          resource
        END
      END
    END
  END
END


// Fixes malformed 2DA files. Can also be used to add new columns.
DEFINE_PATCH_FUNCTION a7_fill_2da_cols
INT_VAR
  expand_header = 1     // Whether to expand header row
  num_cols      = "-1"  // Default: Count table columns
STR_VAR
  def_value     = ~~    // Default: Read from table
BEGIN
  PATCH_IF (num_cols < 0) BEGIN
    COUNT_2DA_COLS num_cols
  END

  READ_2DA_ENTRIES_NOW ~tooltip~ 1

  PATCH_IF (~%def_value%~ STR_EQ ~~) BEGIN
    READ_2DA_ENTRY_FORMER ~tooltip~ 1 0 def_value
  END

  PATCH_IF (expand_header) BEGIN
    // processing header
    FOR (col = 0; col < num_cols; ++col) BEGIN
      PATCH_IF (NOT VARIABLE_IS_SET $tooltip(~2~ ~%col%~)) BEGIN
        SET col = num_cols
        READ_2DA_ENTRY_FORMER ~tooltip~ 2 0 line
        FOR (col = 1; col < num_cols - 1; ++col) BEGIN
          PATCH_IF (VARIABLE_IS_SET $tooltip(~2~ ~%col%~)) BEGIN
            READ_2DA_ENTRY_FORMER ~tooltip~ 2 col value
          END ELSE BEGIN
            SET value = col + 1
          END
          SPRINT line ~%line% %value%~
        END
        REMOVE_2DA_ROW 2 1
        INSERT_2DA_ROW 2 1 ~%line%~
        SET col = num_cols
      END
    END
  END

  // processing data
  FOR (row = 3; row < tooltip; ++row) BEGIN
    FOR (col = 0; col < num_cols; ++col) BEGIN
      PATCH_IF (NOT VARIABLE_IS_SET $tooltip(~%row%~ ~%col%~)) BEGIN
        READ_2DA_ENTRY_FORMER ~tooltip~ row 0 line
        FOR (col = 1; col < num_cols; ++col) BEGIN
          PATCH_IF (VARIABLE_IS_SET $tooltip(~%row%~ ~%col%~)) BEGIN
            READ_2DA_ENTRY_FORMER ~tooltip~ row col value
          END ELSE BEGIN
            SPRINT value ~%def_value%~
          END
          SPRINT line ~%line% %value%~
        END
        REMOVE_2DA_ROW row 1
        INSERT_2DA_ROW row 1 ~%line%~
        SET col = num_cols
      END
    END
  END
  PRETTY_PRINT_2DA
END
